const axios = require('axios');
var http = require('http');
const HTTPAgent = new http.Agent({ keepAlive: true });
var express = require('express');
var app = express();
app.use(express.json());

const MongoClient = require('mongodb').MongoClient;
const fs = require('fs');
var args = process.argv;
const crypto = require('crypto');
const EC = require('elliptic').ec;
const ec = new EC('secp256k1');

var ipList=[], height=0, round=0, ID, leader, member=6, url="", publicKeyList=[];
var mgdb, numVote, fault=1, getBlock, TO1, TO2, blockBody;
var readyMem=0, rfReady=0, dbReady=0, saveblock = [], synheight, synround = -1;
const buffer = new ArrayBuffer(16384);	//1MB	1024		4096		16384

//=====main=====
main();
function main(){
	fs.readFile(args[2], function(err, data) {
		if (err) return console.log(err);
		readfile = data.toString().split('\n');
		
		for(i=0;i<member-1;i++){
			ipList[i] = readfile[i+3].replace(/[\r\n]/g,"");
			publicKeyList[i] = readfile[member+i+2].replace(/[\r\n]/g,"");
		}
		
		app.listen(readfile[0]);
		ID = readfile[1];
		privateKey = ec.keyFromPrivate(readfile[2]);
		
		rfReady = 1;
		if(dbReady==1 && ID!=0)
			singleDeliver("Ready",0);
	
	MongoClient.connect("mongodb://localhost:27017/YourDB",
		{useNewUrlParser: true,useUnifiedTopology: true},
		(err, client) => {
			if (err) return console.log(err);
			db2 = client.db(readfile[0]);
			db2.createCollection('collection', function (err, collection) {
				mgdb = collection;
				
				dbReady = 1;
				if(rfReady==1 && ID!=0)
					singleDeliver("Ready",0,0,0);
			});
		});
	});
}





app.post('/Block', function(req, res) {
	console.log(req.body.data);
	var i = (req.body.data.sender > ID) ? parseInt(req.body.data.sender)-1 : parseInt(req.body.data.sender);
	
	if(customVerify(req.body.data)){
		if(!leader  &&  req.body.data.height == height  &&  req.body.data.round == round){
			numVote++;
			console.log('Get Block');
			broadcastVote();
			getBlock = 1;
			blockBody = req.body;
		}
		else if(req.body.data.height > height  &&  saveblock.indexOf(req.body.data.height) == -1){
			console.log("Ask for synBlock");
			singleDeliver("SynReq", i, req.body.data.height, req.body.data.round, 0);
		}
	}
	res.end();
});

app.post('/Votes', function(req, res) {
	console.log(req.body.data);
	var i = (req.body.data.sender > ID) ? parseInt(req.body.data.sender)-1 : parseInt(req.body.data.sender);
	
	if(customVerify(req.body.data)){
		if(req.body.data.height == height  &&  req.body.data.round == round)
			numVote++;
		else if(req.body.data.height > height  &&  saveblock.indexOf(req.body.data.height) == -1){
			console.log("Ask for synBlock");
			singleDeliver("SynReq", i, req.body.data.height, req.body.data.round, 0);
		}
		if(numVote >= 4*fault+1){
			console.log(numVote);
			saveblock.push(req.body.data.height);
			mgdb.insertOne(blockBody);
			t1Stop();
			t2Stop();
			newHeight();
		}
	}
	res.end();
});

app.post('/SynReq', function(req, res) {
	console.log(req.body.data);
	var i = (req.body.data.sender > ID) ? parseInt(req.body.data.sender)-1 : parseInt(req.body.data.sender);
	
	if(customVerify(req.body.data)){
		mgdb.find({
			type:"Block", 
			height:{	"$gte": req.body.data.height, "$lt": req.body.data.rH	}
		}).toArray(function(err,items){	if(err) throw err;
			console.log("Res for synBlock");
			singleDeliver("SynRes",i,req.body.data.rH,0,items);
        });
	}
	res.end();
});

app.post('/SynRes', function(req, res) {
	console.log(req.body.data.items);
	
	if(customVerify(req.body.data)){
		for(var j=0; j<req.body.data.items.length; j++){
			console.log("Choose the synblock to verify");
			if(customVerify(req.body.data.items[j].data)){
				console.log("Verify the synblock to commit");
				
				verifyblock = {
					type: "Block",
					height: req.body.data.items[j].height,
					data: req.body.data.items[j].data,
				}
				
				if(saveblock.indexOf(req.body.data.items[j].data.height) == -1){
					saveblock.push(req.body.data.items[j].data.height);
					mgdb.insertOne(verifyblock);
				}
			}
		}
	}
	height = req.body.data.synheight-1;
	synround = req.body.data.round-1;
	t1Stop();
	t2Stop();
	newHeight();
	res.end();
});





function broadcastDeliver(mesType){
	var data = {
		type: mesType,
		height: height,
		round: round,
		sender: ID
		}
	if(mesType == "Block"){
		data.buffer = buffer;
	}
	const context = crypto.createHash('sha256').update(JSON.stringify(data)).digest('hex');
	const signature = privateKey.sign(context, 'base64').toDER('hex');
	data.context = context;
	data.signature = signature;
	
	if(mesType == "Block"){
		blockBody = {
			type: mesType,
			height: height,
			data
		}
	}
	
	for(i=0; i<member-1; i++){
		axios({
			method: 'post',
			url: ipList[i].concat("/" + mesType),
			data: {
				type: mesType,
				height: height,
				data
			}
			//httpAgent: HTTPAgent,
		})
		.then(function (res){	/*console.log(res);*/	})
		.catch(function (err){	/*console.log(err);*/	});
	}
}

function singleDeliver(mesType, recipient, reqHeight, reqRound, items){
	var data = {
		type: mesType,
		height: height,
		round: round,
		sender: ID
	}
	if(mesType == "SynReq"){
		data.rH = reqHeight;
		data.rR = reqRound;
	}
	if(mesType == "SynRes"){
		data.items = items;
		data.synheight = reqHeight;
	}
	const context = crypto.createHash('sha256').update(JSON.stringify(data)).digest('hex');
	const signature = privateKey.sign(context, 'base64').toDER('hex');
	data.context = context;
	data.signature = signature;
	
	axios({
		method: 'post',
		url: ipList[recipient].concat("/" + mesType),
		data: {
			type: mesType,
			height: height,
			data
		}
		//httpAgent: HTTPAgent
	})
	.then(function (res){	/*console.log(res);*/	})
	.catch(function (err){	/*console.log(err);*/	});
}

function customVerify(message){
	var i = (message.sender > ID) ? parseInt(message.sender)-1 : parseInt(message.sender);
	const publicKey = ec.keyFromPublic(publicKeyList[i], 'hex');
	
	return publicKey.verify(message.context, message.signature);
}

app.post('/Ready', function(req, res) {
	console.log(req.body.data);
	if(ID == 0){
		if(customVerify(req.body.data)){
			readyMem++;
			if(readyMem == member-1){
				broadcastDeliver("Ready");
				setTimeout(function(){
					Timing1();
					Timing2();
					Timing3();
					newHeight();
				},500);
			}
		}
	}
	else
		newHeight();
	
	res.end();
});





function newRound(){
	leader = 0;
	numVote = 0;
	getBlock = 0;
	round++;
	
	if(ID == (height+round-2)%member){
		leader = 1;
		numVote = 1;
	}
		
	console.log('====== leader= ', leader, 'height = ', height, 'round= ', round);
	
	if(leader){
		console.log('broadcastBlock');
		broadcastBlock();
	}
	t1Start();
	t2Start();
}

function newHeight(){
	synblock = 0;	//避免像兩者以上發出syn請求.而之後commit多個同height的block
	height++;
	TO1 = (synround != -1) ? 1000 * Math.pow(2, synround-1) : 1000;
	TO2 = (synround != -1) ? 2000 * Math.pow(2, synround-1) : 2000;
	round = (synround != -1) ? synround : 0;
	synround = -1;
	newRound();
}

function t1Start(){
	t1 = setTimeout(function(){
		if(!getBlock && !leader){
			console.log('broadcastVoteTO1', 'height = ', height, 'round = ', round);
			broadcastVote();
		}
	},TO1);
}
function t2Start(){
	t2 = setTimeout(function(){
			TO1 = TO1*2;
			TO2 = TO2*2;
			console.log(numVote);
			newRound();
	},TO2);
}
function t1Stop() {	clearTimeout(t1);	}
function t2Stop() {	clearTimeout(t2);	}
function broadcastBlock(){	broadcastDeliver("Block");	}
function broadcastVote(){	broadcastDeliver("Votes");	}
function broadcastReady(){	broadcastDeliver("Ready");	}
function Timing1(){
	setTimeout(function(){
		fs.appendFile('timeing.txt', height, function (err) {	if(err)	console.log(err);	})
	},300000);
}
function Timing2(){
	setTimeout(function(){
		fs.appendFile('timeing.txt', height, function (err) {	if(err)	console.log(err);	})
	},3600000);
}
function Timing3(){
	setTimeout(function(){
		fs.appendFile('timeing.txt', height, function (err) {	if(err)	console.log(err);	})
	},1800000);
}